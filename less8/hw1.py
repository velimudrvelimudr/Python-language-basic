"""
Университет GeekBrains
Курс: Основы языка Python.
Урок 8.
Задание 1.
Автор: Михаил Духонин
Создан: 03 Июнь 2020.
Задание:
Лото.
Игра ведется с помощью спе циальных карточек, на которых отмечены числа,
и фишек (бочонков) с цифрами.

Количество бочонков  90 штук (с цифрами от 1 до 90).

Каждая карточка содержит 3 строки по 9 клеток. В каждой строке по 5 случайных цифр,
расположенных по возрастанию. Все цифры в карточке уникальны. Пример карточки:

--------------------------
    9 43 62          74 90
 2    27    75 78    82
   41 56 63     76      86
--------------------------

В игре 2 игрока: пользователь и компьютер. Каждому в начале выдается
случайная карточка.

Каждый ход выбирается один случайный бочонок и выводится на экран.
Также выводятся карточка игрока и карточка компьютера.

Пользователю предлагается зачеркнуть цифру на карточке или продолжить.
Если игрок выбрал "зачеркнуть":
    Если цифра есть на карточке - она зачеркивается и игра продолжается.
    Если цифры на карточке нет - игрок проигрывает и игра завершается.
Если игрок выбрал "продолжить":
    Если цифра есть на карточке - игрок проигрывает и игра завершается.
    Если цифры на карточке нет - игра продолжается.

Побеждает тот, кто первый закроет все числа на своей карточке.

Пример одного хода:

Новый бочонок: 70 (осталось 76)
------ Ваша карточка -----
 6  7          49    57 58
   14 26     -    78    85
23 33    38    48    71
--------------------------
-- Карточка компьютера ---
 7 87     - 14    11
      16 49    55 88    77
   15 20     -       76  -
--------------------------
Зачеркнуть цифру? (y/n)

Подсказка: каждый следующий случайный бочонок из мешка удобно получать
с помощью функции-генератора.

Подсказка: для работы с псевдослучайными числами удобно использовать
модуль random: http://docs.python.org/3/library/random.html
"""

# Импорт
from random import randrange
from copy import deepcopy

# Функции.

class Cart:
    """Экземпляр класса содержит в себе карточку для игры в лото. Также можно получить матрицу содержащихся в ней чисел."""
    def __init__(self):
        all_numbers = list(range(1, 91)) # массив чисел, из которых будет формироваться карточка.
        small_cart = [] # контейнер для матрицы карточки.
        # Формирование матрицы:
        for row in [0, 1, 2]:
            small_cart.append([]) # На каждой итерации добавляем в матрицу пустую строку.
            for cell in [0,1,2,3,4]:
                small_cart[row].append(all_numbers.pop(randrange(0, len(all_numbers)))) # добавляем в строку случайно выбранное число из списка all_numbers, причём само это число из all_numbers удаляется.
            small_cart[row].sort() # сортируем строку по возрастанию согласно ТЗ.
        self.small_cart = small_cart # Атрибут с матрицей.

        cart = deepcopy(self.small_cart) # Глубокое копирование матрицы в переменную для формирования карточки.
        for row in cart:
            while len(row) < 9:
                row.insert(randrange(0, len(row)), '  ') # Добавляем в случайное место строки карточки два пробела, пока общее число клеток не станет равным 9.
        self.cart = cart # Собственно, готовая карточка.

    def __str__(self):
        return '\n'.join([' '.join(map(str, r)) for r in self.cart])

    def del_number(self, number):
        """Зачёркивает цифру в карточке и удаляет из матрицы."
        
        param1: удаляемое число.
        Если число отсутствует в карточке, генерируется исключение, иначе возвращается количество пустых строк в карточке."""

        flagg = False # Становится True, если число присутствует и было удалено.
        empty_rows_count = 0 # количество пустых строк.

        for r in [0, 1, 2]:
            if number in self.small_cart[r]:
                self.small_cart[r].remove(number)
                self.cart[r][self.cart[r].index(number)] = '  '
                flagg = True
            if len(self.small_cart[r]) == 0:
                empty_rows_count += 1
        if flagg == True:
            return empty_rows_count
        else:
            raise Exception(f'Элемента {number} не существует')


class BagKegs:
    """Мешок с бочонками.

    Экземпляр является итерируемым объектом. На каждой итерации выдаёт один бочонок, который удаляется из мешка."""
    def __init__(self):
        self.kegs = list(range(1, 91)) # Собственно мешок, в который здесь насыпаются бочонки.

    def __next__(self):
        if len(self.kegs) != 0:
            return self.kegs.pop(randrange(0, len(self.kegs))) # вытаскивает бочонок и удаляет его из мешка.
        else:
            raise StopIteration

    # Для меня стало загадкой, зачем в методичке разделили объект-идератор, который не может итерироваться, и итерируемый объект. У меня всё в одном месте...
    def __iter__(self):
        return self

    def __str__(self):
        return f"В мешке находятся бочонки со следующими номерами:\n{' '.join(self.kegs)}"

    @property
    def take_keg(self):
        """Так, на всякий случай, метод-свойство, достающий бочонок из мешка. Если вдруг руками достать захочется..."""
        try:
            return self.kegs.pop(randrange(0, len(self.kegs)))
        except ValueError:
            return "Бочонки в мешке  закончились!"

def main():
    """Я так и не придумал, как загнать игру в класс, чтобы это было не натягиванием совы на глобус.

        Ограничился функцией, которая выполняет алгоритм игры, печатает в консоль сообщения игры и возвращает сообщения, по какому 
        поводу игра закончилась."""

    # Блок приветствия и инициализации переменных.
    comp_name = "Компи"

    print(f"Привет! Меня зовут {comp_name}.")

    for i in [1, 2, 3]: # Геймеру даётся три попытки, чтобы правильно ответить на вопрос Компи.
        begin = input("Ну что, сыграем в лото?\n(да/нет): ").lower()
        if begin == "нет":
            return "Ну как хочешь..."
        elif begin == "да":
            gamer_name = input("Отлично! Как тебя зовут? ")
            print(f"{gamer_name}, очень приятно, Поехали!")
            break
        elif i == 3:
            return "Ты меня достал! Не можешь по-человечески ответить на простой вопрос. Попробуй в следующий раз."
        else:
            print("Я не понял тебя. Давай ещё раз...")

    comp_cart = Cart()
    gamer_cart = Cart()
    bag_kegs = BagKegs()
    ccerc, gcerc = 0, 0 # Количество пустых строк в карточках Компи и геймера. Когда число у кого-нибудь становится равным 3, игра завершается.
    c, g = 0, 0
    # Основной цикл игры.
    for keg in bag_kegs:
        print(f"""Достали бочонок {keg}, В мешке осталось {len(bag_kegs.kegs)}.\n
            Моя карточка:\n{comp_cart}
            \nТвоя карточка:\n{gamer_cart}""")


        try:
            ccerc = comp_cart.del_number(keg) # Компи тупо пытается зачеркнуть выпавшее число, ибо знает, что неудачная попытка будет правильно обработана.
        except Exception:
            pass

        hod = input(f"Ну что, {gamer_name}, зачёркиваем, или как?\n(да/нет): ").lower()

        for i in [1, 2, 3]:
            if not (hod in ("да", "нет")):
                print(f"{gamer_name}, Я тебя не понял. Попробуй ещё раз.")
                hod = input('"да" или "нет?" ').lower()
                continue
            elif i == 3:
                return f"{gamer_name}, ты мне надоел! Три раза подряд не суметь ввести простое слово - это нужно постараться! Ты проиграл, в общем."
            else:
                break

    # Анализ хода.
        try:
            gcerc = gamer_cart.del_number(keg)
            if hod == "нет":
                return f'А число {keg} в твоей карточке было...\nУвы, {gamer_name}, Ты был невнимателен и проиграл.'
        except Exception as e:
            if hod == "да":
                return f'{e}\nУвы, {gamer_name}, Ты проиграл.'
    # Анализ состояния игры - заполнение карточек и определение победителя.

        if ccerc == 3 == gcerc:
            print(f'Мы закрыли карточки одновременно... Игра закончилась вничью')
            return 'Ничья!'

        if ccerc == 3:
            print(f'Ура! Я выиграл!\n{gamer_name}, тебе обязательно повезёт в следующий раз.')
            return f'Победа {comp_name}.'

        if gcerc == 3:
            print(f'Ну вот, ты выиграл... Но в следующий раз я обязательно отыграюсь!')
            return f"Победил {gamer_name}."

        if ccerc - c ==1:
            c = ccerc
            print(f'О, я уже зачеркнул {ccerc}-ую строчку! Сейчас я тебя сделаю!')

        if gcerc - g == 1:
            g = gcerc
            print(f'О, ты уже зачеркнул {gcerc}-ую строчку! До победы осталось совсем немного!')

if __name__ == '__main__':
    print(main())
